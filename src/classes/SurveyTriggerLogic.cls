/**
 * Class contains all the logic that is carried out by a trigger on the Survey__c object.
 * Any new logic that needs to be added to the Survey__c trigger goes in here and to the relevant
 * methods
 * This class should deprecate the following triggers:-
 *     CleanXForm
 *     CreateVersionOnSurveyUpdateInsert
 *     SetPPISurveyName
 * (c) Copyright 2013 Grameen Foundation USA. All rights reserved
 *
 * @author - Owen Davies
 * @author - Aditi Satpute
 */
global with Sharing class SurveyTriggerLogic extends TriggerHandler {

    // Override the checks for manual status updates. To allow deletion
    private static Boolean overrideStatusUpdate = false;

    // Setter converted to global to be able to use it from outside of the package
    // Related to IDALMSA-3676
    global static void setOverrideDeleteChecks(Boolean value) {
        overrideStatusUpdate = value;
    }

    // This is needed to skip the before update logic when onlysaving a quesstion during tests
    private static Boolean overrideChecksWhenSavingQuestion = false;

    // Setter converted to global to be able to use it from out side of the package
    // Related to IDALMSA-3676
    global static void setOverrideChecksWhenSavingQuestion(Boolean value) {
        overrideChecksWhenSavingQuestion = value;
    }

    private SurveyDO getTriggerDomain() {
        return (SurveyDO) this.domain;
    }

    public override void validateBefore() {
        // Check for duplicate aliases
        checkForDuplicateAlias(
            getAliasesToValidate(
                (Map<Id, Survey__c>) trigger.oldMap,
                trigger.new,
                new Set<String>()
            ),
            (Map<Id, Survey__c>) trigger.newMap,
            trigger.new,
            trigger.isInsert
        );

        // Check the name of the surveys
        checkPpiSettings(trigger.new, trigger.isInsert);
    }

    /**
     * Before Insert
     *
     * Check to be carried out:-
     *     - Check that the PPI settings are valid
     *     - Check not adding an alias that already exisits
     *     - Check that the survey is a PPI Template with RemoteId not present
     *
     * Actions carried out:-
     *     - Set the status of the survey to draft and set version to 1
     *     - Set the ppiIdentifier of survey
     */
    public override void onBeforeInsert() {
        beforeInsert(
            trigger.new,
            (Map<Id, Survey__c>) trigger.newMap
        );
        getTriggerDomain().setPpiIdentifier((List<Survey__c>) getRecords());
    }

    /**
     * After Insert
     *
     * Actions carried out:-
     *     - Create the versions for the surveys. All as version 1
     */
    public override void onAfterInsert() {
        afterInsert(trigger.new);
    }

    /**
     * Before update
     *
     * Check to be carried out:-
     *     - Check that the PPI settings are valid
     *     - Prevent to change the survey status manually
     *     - Check that the survey is a PPI Template with RemoteId not present
     *
     * Actions carried out:-
     *     - Remove any out of date xforms
     *     - Create the versions for the surveys. All versions are incremented
     *       from the previous version
     *     - Set the ppiIdentifier of survey
     */
    public override void onBeforeUpdate(Map<Id, sObject> oldMap) {
        beforeUpdate(
            (Map<Id, Survey__c>) oldMap,
            trigger.new,
            (Map<Id, Survey__c>) trigger.newMap
        );
        getTriggerDomain().setPpiIdentifier(
            (Map<Id, Survey__c>) oldMap,
            (List<Survey__c>) getRecords()
        );
    }

    /**
     * After Update
     *
     * Checks to be carried out:-
     *     - Validate that there aren't questions with the same position
     */
    public override void onAfterUpdate(Map<Id, sObject> oldMap) {
        afterUpdate(trigger.new, (Map<Id, Survey__c>) trigger.newMap);
    }

    /**
     * Before Delete
     *
     * Checks to be carried out:-
     *     - Check that the survey is not published (unless overriddden for QA or demo org)
     *     - Check that the survey is not referenced by any tasks
     *
     * Actions carried out:-
     *     - Delete any survey mappings
     *     - Delete PPI Table Data Sets if the survey is a PPI survey
     */
    public override void onBeforeDelete() {
        beforeDelete(trigger.old);
    }

    /**
     * @param triggerNewList - The list of surveys being inserted by the trigger
     * @param triggerMewMap  - A map of the new versions of the surveys.
     *                         Generated by calling Trigger.newMap
     */
    public static void beforeInsert(
            List<Survey__c> triggerNewList,
            Map<Id, Survey__c> triggerNewMap
    ) {

        GenericObjectCreator surveyCreator =
            new GenericObjectCreator(Survey__c.SObjectType);

        // Set the version and status for the surveys
        for (Survey__c survey : triggerNewList) {
            surveyCreator.populateFields(
                survey,
                new Map<Schema.SObjectField, Object>{
                    Survey__c.Version__c => 1,
                    Survey__c.Status__c => SurveyDO.STATUS_DRAFT,
                    Survey__c.PublishedDate__c => null
                }
            );
        }
    }

    /**
     * @param triggerOldMap  - A map of the old versions of the surveys.
     *                         Generated by calling Trigger.oldMap
     * @param triggerNewList - The list of surveys being inserted by the trigger
     * @param triggerMewMap  - A map of the new versions of the surveys.
     *                         Generated by calling Trigger.newMap
     */
    public static void beforeUpdate(
            Map<Id, Survey__c> triggerOldMap,
            List<Survey__c> triggerNewList,
            Map<Id, Survey__c> triggerNewMap
    ) {

        if (Test.isRunningTest() && overrideChecksWhenSavingQuestion) {
            return;
        }

        // Get the most recent version for each survey
        Map<Id, SurveyVersion__c> lastVersionBySurveyId =
            new SurveyVersionSelector().getLatestSurveyVersion(triggerNewList);

        List<SurveyVersion__c> newVersions = new List<SurveyVersion__c>();
        Set<Id> surveysUpdated = new Set<Id>();

        for (Survey__c survey : triggerNewList) {

            // Check that the status has not been changed manually on the survey detail page.
            // Survey status should only be changed by changing the status on the latest version
            // Or by adding a new version for that survey
            Survey__c oldSurvey = triggerOldMap.get(survey.Id);

            // Default the existing version status just incase and no version exists. e.g. when
            // running postInstall Script
            String status = 'NONE';

            if (lastVersionBySurveyId.containsKey(survey.Id)) {
                status = lastVersionBySurveyId.get(survey.Id).Status__c;
            }
            if (
                survey.Status__c != oldSurvey.Status__c &&
                survey.Status__c != status &&
                !overrideStatusUpdate
            ) {
                survey.addError(System.Label.ERR_AVOID_EDIT_SURVEY_STATUS_MANUALLY);
                continue;
            }

            // Delete the xform if a field other than XForm_Status or Status has changed
            if (
                oldSurvey.XForm_Status__c == survey.XForm_Status__c &&
                oldSurvey.Status__c == survey.Status__c &&
                survey.Status__c == SurveyDO.STATUS_DRAFT
            ) {
                surveysUpdated.add(survey.Id);
                survey.XForm_Status__c = C.XFORM_STATUS_DEFAULT;
            }

            GenericObjectCreator surveyVersionCreator =
                new GenericObjectCreator(SurveyVersion__c.SObjectType);
            surveyVersionCreator.checkObjectAccessible();
            surveyVersionCreator.checkFieldsAccessible(
                new List<String> {
                    'Status__c',
                    'Version__c',
                    'Survey__c'
                }
            );

            // Only add a new version if the survey has been taken back into draft status
            if (oldSurvey.Status__c != SurveyDO.STATUS_DRAFT &&
                    survey.Status__c == SurveyDO.STATUS_DRAFT
            ) {
                survey.Version__c ++;
                SurveyVersion__c surveyVersionInstance =
                    (SurveyVersion__c) surveyVersionCreator.createNewRecord();
                surveyVersionCreator.populateFields(
                    surveyVersionInstance,
                    new Map<Schema.SObjectField, Object>{
                        SurveyVersion__c.Survey__c => survey.Id,
                        SurveyVersion__c.Status__c => SurveyDO.STATUS_DRAFT,
                        SurveyVersion__c.Version__c => survey.Version__c
                    }
                );
                newVersions.add(surveyVersionInstance);
            }
        }

        // Only check for permissions if we need to insert any records
        if (newVersions != null && newVersions.size() > 0) {
            SurveyVersionDomain surveyVersionDomainInstance =
                new SurveyVersionDomain.Constructor().constructWithRecords(
                    newVersions
                );
            surveyVersionDomainInstance.insertRecords();
        }

        // Delete any old xform attachments that are connected to surveys that have been updated
        if (surveysUpdated.size() > 0) {

            // Get the last version that is in draft
            Set<Id> versionIds = new Set<Id>();
            for (Id surveyId : surveysUpdated) {
                if (lastVersionBySurveyId.containsKey(surveyId)) {
                    versionIds.add(lastVersionBySurveyId.get(surveyId).Id);
                }
            }

            AttachmentDomain attachmentDomainInstance =
                new AttachmentDomain.Constructor().constructWithRecords(
                    new AttachmentSelector().getAllWithParentId(
                        versionIds,
                        XFormCreator.XFORM_ATTACHMENT
                    )
                );
            attachmentDomainInstance.deleteRecords();
        }
    }

    /**
     * @param triggerOldList - The list of surveys being deleted by the trigger
     */
    public static void beforeDelete(List<Survey__c> triggerOldList) {

        Boolean deletingPpiSurvey = false;
        Set<String> surveyIds = new Set<String>();
        List<Id> ppiSurveyIds = new List<Id>();

        for (Survey__c survey : triggerOldList) {
            surveyIds.add(survey.Id);
            if (survey.IsPPI__c) {
                ppiSurveyIds.add(survey.Id);
            }
        }

        // Get all tasks that the surveys are linked to
        List<TaskTemplate__c> tasks =
            new TaskTemplateSelector().getAllForSurveyIds(surveyIds);

        // Loop through deleted surveys and carry out checks
        for (Survey__c survey : triggerOldList) {

            // Stop surveys being deleted if they are published unless over ridden by 
            // custom setting or by flag. Published survey is a survey with a published date
            if (
                    survey.PublishedDate__c != null &&
                    (
                        ApplicationSettingsUtils.getInstanceWithName(
                            C.FLAG_SKIP_SURVEY_STATUS_VALIDATION
                        ) == null && !overrideStatusUpdate
                    )
            ) {
                survey.Status__c.addError(system.label.SURVEY_ERR_CANNOTDELETEPUBLISHED);
            } else if (
                    survey.Status__c.equals(SurveyDO.STATUS_DRAFT) &&
                    (
                        ApplicationSettingsUtils.getInstanceWithName(
                            C.FLAG_SKIP_SURVEY_STATUS_VALIDATION
                        ) == null && !overrideStatusUpdate
                    )
             ) {

                // Check that the survey is not referenced by any tasks
                for (TaskTemplate__c task : tasks) {

                    // If is referenced then show error message
                    if (task.Form__r.Survey__c == survey.Id) {
                        survey.addError(System.Label.SURVEY_ERR_CANNOTDELETERELATEDTOTASK);
                    }
                }
            }
        }

        // Remove SurveyMapping__c objects for the deleted surveys
        SurveyMappingDomain surveyMappingDomainInstance =
            new SurveyMappingDomain.Constructor().constructWithRecords(
                 new SurveyMappingSelector().getAllForSurveyIds(surveyIds)
            );
        surveyMappingDomainInstance.deleteRecords();

        if (!ppiSurveyIds.isEmpty()) {
            PpiTableDataSetDomain ppiTableDataSetDomainInstance =
                new PpiTableDataSetDomain.Constructor().constructWithRecords(
                    new PpiTableDataSetSelector().getAllForSurveys(ppiSurveyIds)
                );
            ppiTableDataSetDomainInstance.deleteRecords();
        }
    }

    /**
     * @param triggerNewList - The list of surveys being inserted by the trigger
     */
    public static void afterInsert(List<Survey__c> triggerNewList) {
        GenericObjectCreator surveyVersionCreator =
            new GenericObjectCreator(SurveyVersion__c.SObjectType);
        surveyVersionCreator.checkObjectAccessible();
        surveyVersionCreator.checkFieldsAccessible(
            new List<String> {
                'Status__c',
                'Version__c',
                'Survey__c'
            }
        );

        List<SurveyVersion__c> versions = new List<SurveyVersion__c>();
        for (Survey__c survey : triggerNewList) {
            SurveyVersion__c surveyVersionInstance =
                (SurveyVersion__c) surveyVersionCreator.createNewRecord();
            surveyVersionCreator.populateFields(
                surveyVersionInstance,
                new Map<Schema.SObjectField, Object>{
                    SurveyVersion__c.Survey__c => survey.Id,
                    SurveyVersion__c.Status__c => SurveyDO.STATUS_DRAFT,
                    SurveyVersion__c.Version__c => 1
                }
            );
            versions.add(surveyVersionInstance);
        }
        SurveyVersionDomain surveyVersionDomainInstance =
            new SurveyVersionDomain.Constructor().constructWithRecords(
                versions
            );
        surveyVersionDomainInstance.insertRecords();
    }

    /**
     * @param triggerNewList - The list of surveys being inserted by the trigger
     * @param triggerMewMap  - A map of the new versions of the surveys. Generated by calling Trigger.newMap
     */
    public static void afterUpdate(List<Survey__c> triggerNewList, Map<Id, Survey__c> triggerNewMap) {

        Survey__c currentSurvey = null;
        Question__c prevQuestion = null;

        // Get all questions from the edited survey.
        // Skip questions that do not belong to the survey's current draft version (since those can't be edited)
        if (ApplicationSettingsUtils.getInstanceWithName(
                C.FLAG_SKIP_QUESTION_POSITION_VALIDATION 
            ) == null
        ) {
            Set<String> surveyIds = new Set<String>();
            for (Survey__c survey : triggerNewList) {
                surveyIds.add(survey.Id);
            }
            List <Question__c> questions =
                new QuestionSelector().getAllForSurveyIds(surveyIds, 1);

            for (Question__c question : questions) {

                // Non-draft surveys cannot be edited, so if they have invalid positions, they will stay as such.
                if (question.Survey__r.Status__c != SurveyDO.STATUS_DRAFT) {
                    continue;
                }

                if (currentSurvey == null || currentSurvey.Id != question.Survey__c) {
                    currentSurvey = triggerNewMap.get(question.Survey__c);
                }

                // Raise an error if the question shares position with the previous question
                if (
                        prevQuestion != null &&
                        question.Survey__c == prevQuestion.Survey__c &&
                        question.Parent__c == prevQuestion.Parent__c &&
                        question.Position__c == prevQuestion.Position__c
                ) {
                    currentSurvey.addError(String.format(
                        system.Label.QUESTION_ERR_WRONGORDERTRIGGER,
                        new String[]{
                            question.Name,
                            question.Id,
                            prevQuestion.Name,
                            prevQuestion.Id,
                            question.Parent__c,
                            String.ValueOf(question.Position__c)
                        }
                    ));
                }
                prevQuestion = question;
            }
        }
    }

    /**
     * Check that the user has the license and and that the country and language settings are valid.
     * Attaches an error if the checks fail
     *
     * @param triggerNewList - List of the surveys being created/edited
     * @param isInsert       - Context of the trigger
     */
    private static void checkPpiSettings(List<Survey__c> triggerNewList, Boolean isInsert) {

        LicenseSettings__c licence = C.getLicense();
        for (Survey__c newSurvey : triggerNewList) {

            if (newSurvey.isPPI__c) {

                // Rise an error if insert a new PPI survey without licence
                if (isInsert && !newSurvey.IsCloned__c
                        && !licence.UsePPI__c && !licence.PPI_Editable__c
                ) {
                    newSurvey.addError(System.label.SYSTEM_ERR_NOLICENSEPERMISSION);
                }

                // Rise an error if the country or the language is null
                ISO_Country__c country  =
                    ISOCountryWrapper.getInstanceWithName(newSurvey.CountryCode__c);
                Language__c language =
                    LanguageWrapper.getInstanceWithName(newSurvey.LanguageCode__c);
                if (country == null) {
                    newSurvey.CountryCode__c.addError(
                        String.format(
                            System.label.SURVEY_ERR_INVALIDCOUNTRYCODE,
                            new String[] {newSurvey.CountryCode__c}
                        )
                    );
                }
                if (language == null) {
                    newSurvey.LanguageCode__c.addError(
                        String.format(
                            System.label.SURVEY_ERR_INVALIDLANGUAGECODE,
                            new String[] {newSurvey.LanguageCode__c}
                        )
                    );
                }
            }
        }
    }

    /**
     * Get all the aliases that have changed.
     *
     * @param triggerOldMap     - A map of the old versions of the surveys.
                                  Generated by calling Trigger.oldMap
     * @param triggerNewList    - List of surveys being changed by the user.
                                  Generated by calling Trigger.new
     * @param aliasesToValidate - A set of the aliases that have been changed
     *
     * @return - A set of the Aliases that have changed
     */
    private static Set<String> getAliasesToValidate(
            Map<Id, Survey__c> triggerOldMap,
            List<Survey__c> triggerNewList,
            Set<String> aliasesToValidate
    ) {

        for (Survey__c survey : triggerNewList) {
            if (triggerOldMap == null
                    || (triggerOldMap != null && survey.Alias__c != triggerOldMap.get(survey.Id).Alias__c)
            ) {
                if (survey.Alias__c != null) {
                    aliasesToValidate.add(survey.Alias__c);
                }
            }
        }
        return aliasesToValidate;
    }

    /**
     * Check for any surveys that have the same alias as the surveys being created/updated.
     * Errors are attached to any survey with a clashing alias.
     *
     * @param aliases        - A set of the aliases being checked
     * @param triggerNewMap  - Map of surveys being changed by the user.
                               Generated by calling Trigger.newMap
     * @param triggerNewList - List of surveys being changed by the user.
                               Generated by calling Trigger.new
     * @param isInsert       - Boolean indicating that the code is being called on insert
     */
    private static void checkForDuplicateAlias(
            Set<String> aliases,
            Map<Id, Survey__c> triggerNewMap,
            List<Survey__c> triggerNewList,
            Boolean isInsert
    ) {

        if (aliases.isEmpty()) {
            return;
        }

        // Dig out all surveys with the aliases and create a map with the alias as the key
        Map<String, Survey__c> surveysByAlias = new Map<String, Survey__c>();
        for (Survey__c survey : new SurveySelector().getAllByAlias(aliases, false)) {
            surveysByAlias.put(survey.Alias__c, survey);
        }

        // Loop through the triggerNewList and check to see if any of the aliases match.
        // If match found on a different survey add error
        Set<String> newAliases = new Set<String>();
        for (Survey__c survey : triggerNewList) {

            if (String.isEmpty(survey.Alias__c)) {
                continue;
            }

            // Check that the survey alias is not already in the DB or that another survey with the
            // same alias is not being added in this trigger execution
            if (surveysByAlias.containsKey(survey.Alias__c) || newAliases.contains(survey.Alias__c)) {

                // Make sure that the new status for a survey exists. Stops a null pointer being thrown
                // If it doesn't exist that means that the other survey that could 
                // have the same Alias as this one is not being changed
                String referencedSurveyAlias = survey.Alias__c;
                if (triggerNewMap != null && 
                        triggerNewMap.get(surveysByAlias.get(survey.Alias__c).Id) != null
                ) {
                    referencedSurveyAlias =
                        triggerNewMap.get(surveysByAlias.get(survey.Alias__c).Id).Alias__c;
                }

                // If this is an insert throw an error
                // If update check that if the Alias hasn't changed that the survey is the same
                // Or if the alias clashes with another survey, check that the clashing
                // survey is being updated and having its alias changed as well
                if (
                        isInsert ||
                        (
                            survey.Id != surveysByAlias.get(survey.Alias__c).Id &&
                            referencedSurveyAlias == survey.Alias__c
                        )
                ) {
                    survey.addError(system.Label.SURVEY_ERR_DUPLICATE_ALIAS);
                }
            }
            newAliases.add(survey.Alias__c);
        }
    }
}
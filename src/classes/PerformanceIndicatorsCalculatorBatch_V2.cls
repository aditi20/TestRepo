/**
 * Batchable class that will re-calculate all the AssignedTargets for all the
 * Active Performance Indicators
 *
 * (c) Copyright 2013 Grameen Foundation USA. All rights reserved
 *
 * @author - Owen Davies
 * @author - Aditi Satpute
 */
global class PerformanceIndicatorsCalculatorBatch_V2 implements Database.Batchable<SObject>, Database.Stateful {

    global PerformanceIndicatorCategory performanceIndicatorCategory;
    global List<String> objectApiNames;
    global Integer indexForApiNames;
    global Integer dateModifier;
    global Date monthlyStartDate;
    global Date weeklyStartDate;
    global Date startDate;
    global Date endDate;

    // Key to this map is formed by createAssignedTargetMapKey method
    global Map<String, AssignedTarget__c> assignedTargets;

    private static final String SPLITTER = '_#@#_';

    /**
     * Constructor
     */
    global PerformanceIndicatorsCalculatorBatch_V2(
        List<String> objectApiNames,
        Integer indexForApiNames,
        Integer dateModifier
    ) {
        this.dateModifier = dateModifier;
        Date dateBatchRunsUntil = DateTime.now().dateGmt().addDays(dateModifier);
        this.monthlyStartDate = PerformanceTargetDO.getStartOfCurrentTimePeriod(
            dateBatchRunsUntil, PerformanceTargetDO.TIMEFRAME_MONTHLY
        );
        this.weeklyStartDate = PerformanceTargetDO.getStartOfCurrentTimePeriod(
            dateBatchRunsUntil, PerformanceTargetDO.TIMEFRAME_WEEKLY
        );
        this.startDate = getMinorDate(this.monthlyStartDate, this.weeklyStartDate);
        this.endDate = DateTime.now().dateGmt().addDays(dateModifier);
        this.objectApiNames = objectApiNames;
        this.indexForApiNames = indexForApiNames;
        this.performanceIndicatorCategory = new PerformanceIndicatorCategory(
            this.objectApiNames[indexForApiNames]
        );
        this.assignedTargets =
            getAssignedTargets(this.PerformanceIndicatorCategory.getPerformanceTargetIds());
    }

    /**
     * Start method for the batch
     * Checks that the object still exists
     */
    global Database.QueryLocator start(Database.BatchableContext batchableContext) {
        return Database.getQueryLocator(generateBatchQueryString());
    }

    /**
     *  Execute method
     */
    global void execute(Database.BatchableContext batchableContext, List<SObject> batch) {
        GenericObjectCreator assignedTargetCreator =
            new GenericObjectCreator(AssignedTarget__c.SObjectType);
        for (SObject record : batch) {
            for (
                    PerformanceTarget__c performanceTarget :
                    this.performanceIndicatorCategory.getPerformanceTargets()
            ) {
                processPerformanceIndicator(record, performanceTarget);
            }
        }

        // Update the AsssignedTarget__c records
        assignedTargetCreator.checkObjectUpdateable();
        update this.assignedTargets.values();
    }

    /**
     * Finish method for the batch. If there are more objects that have PerformanceIndicators
     * then run the batch again
     */
    global void finish(Database.BatchableContext batchableContext) {

        this.indexForApiNames++;
        this.performanceIndicatorCategory.closePerformanceTarget();
        if (this.indexForApiNames < this.objectApiNames.size()) {
            restartBatch();
        }
    }

    /**
     * Get all the Assigned Targets for the dates being considered and reset the values to 0
     *
     * @param performanceTargets - The ids for the performanceTargets that the are being fetched
     *
     * @return - A map of the assignedTargets with the key generated by
     *             createAssignedTargetMapKey(assignedTarget)
     */
    private Map<String, AssignedTarget__c> getAssignedTargets(
            Set<Id> performanceTargets
    ) {
        GenericObjectCreator assignedTargetCreator =
            new GenericObjectCreator(AssignedTarget__c.SObjectType);
        Map<String, AssignedTarget__c> assignedTargetsMap = new Map<String, AssignedTarget__c>();
        List<AssignedTarget__c> assignedTargets =
            AssignedTargetDO.getRecentAssignedTargetsForPerformanceTargets(
                performanceTargets,
                this.weeklyStartDate,
                this.monthlyStartDate
            );
        for (AssignedTarget__c assignedTarget : assignedTargets) {
            assignedTargetCreator.populateFields(
                assignedTarget,
                new Map<Schema.SObjectField, Object> {
                    AssignedTarget__c.RecordCount__c => 0,
                    AssignedTarget__c.ActualValue__c => 0
                }
            );
            assignedTargetsMap.put(
                createAssignedTargetMapKey(assignedTarget),
                assignedTarget
            );
        }
        return assignedTargetsMap;
    }

    /**
     * Process a record against a performance target
     */
    private void processPerformanceIndicator(
            SObject record,
            PerformanceTarget__c performanceTarget
    ) {
        try {
            if (recordEditedWithinTimeperiod(record, performanceTarget)) {

                // Check that the assignedTarget already exists for this Mobile User
                // If it doesn't then ignore this contact. It can be cleaned up in the next day
                String contactId = getContactId(record, performanceTarget);
                String assignedTargetKey = createAssignedTargetMapKey(
                    performanceTarget.Id,
                    contactId,
                    performanceTarget.StartDate__c
                );
                AssignedTarget__c assignedTarget = this.assignedTargets.get(assignedTargetKey);
                if (assignedTarget != null) {

                    // Apply the numerator filters to the record and increase the ActualValue if needed
                    if (needToIncreaseActualValue(record, performanceTarget.Id)) {
                        AssignedTargetDO.increaseActualValue(
                            assignedTarget,
                            performanceTarget.AggregationOperation__c,
                            Double.valueOf(
                                String.isNotBlank(performanceTarget.TrackedFieldApiName__c) &&
                                PerformanceTargetDO.operationRequireTrackedField(performanceTarget)
                                    ? (
                                        record.get(performanceTarget.TrackedFieldApiName__c) != null
                                            ? record.get(performanceTarget.TrackedFieldApiName__c)
                                            : 0
                                    ) : 0
                            )
                        );
                    }

                    if (
                        !performanceTarget.AggregationOperation__c.equals(
                            PerformanceTargetDO.AGGREGATION_OPERATION_SUM
                        )
                    ) {
                        // Increase the record count only if selected operation is other than SUM
                        assignedTarget.RecordCount__c++;
                    }
                    this.assignedTargets.put(assignedTargetKey, assignedTarget);
                }
            }
        } catch (SObjectFilterConditionDO.SObjectFilterException se) {
            if (se.getFatalError()) {
                this.performanceIndicatorCategory.indicatePerformanceTargetToClose(
                    performanceTarget
                );
            }
        }
    }

    /**
     * Decide if the record was modified during the current weekly time period
     */
    private Boolean recordEditedWithinTimeperiod(
            SObject record,
            PerformanceTarget__c performanceTarget
    ) {
        return !(
            performanceTarget.Timeframe__c.equals(
                PerformanceTargetDO.TIMEFRAME_WEEKLY
            ) &&
            DateTime.valueOf(record.get('LastModifiedDate')).getTime() <
                DBFullAccess.convertToStartDateTime(this.weeklyStartDate).getTime()
        );
    }

    /**
     * Get the id of the related contact
     *
     * @param record            - The current record
     * @param performanceTarget - The indicator target
     *
     * @return - The id of the contact
     */
    private Id getContactId(SObject record, PerformanceTarget__c performanceTarget) {
        SObject currentObject = record;
        List<String> fields =
            performanceTarget.TrackedSObjectContactLookupFieldName__c.split('\\.', 0);
        if (fields.size() > 0) {
            for (Integer i = 0; i < fields.size() - 1; i++) {
                currentObject = currentObject.getSObject(fields[i]);
            }
            return (Id)currentObject.get(fields[fields.size() - 1]);
        } else {
            return null;
        }
    }

    /**
     * Decide if the record passes filters and therefore requires an update of the AssignedTarget
     */
    private Boolean needToIncreaseActualValue(SObject record, Id performanceTargetId) {

        Boolean matchFilter = true;
        for (
                SObjectFilterCondition__c filter :
                    this.performanceIndicatorCategory.getNumeratorFiltersForPerformanceTarget(
                        performanceTargetId
                    )
        ) {
            if (!SObjectFilterConditionDO.doesRecordPassFilter(filter, record)) {
                matchFilter = false;
                break;
            }
        }
        return matchFilter;
    }

    /**
     * Generate the query string for the batch job
     */
    private String generateBatchQueryString() {
        if (DescribeHandler.getGlobalDescribe().containsKey(
                this.performanceIndicatorCategory.getObjectApiName())
        ) {
            GenericObjectCreator genericObjectCreator =
            new GenericObjectCreator(
                DescribeHandler.getGlobalDescribe().get(
                    this.performanceIndicatorCategory.getObjectApiName()
                )
            );
            genericObjectCreator.checkObjectAccessible();
            List<String> fieldsList = new List<String>();
            if (!String.isEmpty(this.performanceIndicatorCategory.getSelectClauseString())) {
                fieldsList =
                    this.performanceIndicatorCategory.getSelectClauseString().Split(',');
            }
            genericObjectCreator.checkFieldsAccessible(fieldsList);
        } 

        return
            'SELECT ' +
                this.performanceIndicatorCategory.getSelectClauseString() + ' ' +
            'FROM ' +
                this.performanceIndicatorCategory.getObjectApiName() + ' ' +
            'WHERE ' +
                'LastModifiedDate >= ' +
                    DBFullAccess.convertDateTimeToGmtSoqlString(DBFullAccess.convertToStartDateTime(
                        getMinorDate(this.monthlyStartDate, this.weeklyStartDate)
                    ), false)
                + ' ' +
                ' AND LastModifiedDate <= ' +
                    DBFullAccess.convertDateTimeToGmtSoqlString(DBFullAccess.convertToEndDateTime(
                        this.endDate
                    ), false)
        ;
    }

    /**
     * Determine which of two dates is first
     */
    private Date getMinorDate(Date testDate, Date dateToCompare) {
        return (testDate.daysBetween(dateToCompare) >= 0)
            ? testDate
            : dateToCompare;
    }

    /**
     * Create a key for the assignedTargetMap
     *
     * @param performanceTargetId - The Id of the PerformanceTarget
     * @param contactId           - The Id for the contact that owns the AssignedTarget
     * @param startDate           - AssignedTarget__c.StartDate__c
     *
     * @return - A String with the following format
     *            performanceTargetId_#@#_contactID_#@#_startDate
     */
    private String createAssignedTargetMapKey(
        Id performanceTargetId,
        Id contactId,
        Date startDate
    ) {
        return performanceTargetId + SPLITTER + contactId + SPLITTER + startDate;
    }

    /**
     * Create a key for the assignedTargetMap from the AssignedTarget record
     *
     * @param assignedTarget - The AssignedTarget__c that needs a key created for it
     *
     * @return - A String with the following format
     *            performanceTargetId_#@#_contactID_#@#_startDate.format
     */
    @TestVisible
    private String createAssignedTargetMapKey(AssignedTarget__c assignedTarget) {
        return createAssignedTargetMapKey(
            assignedTarget.PerformanceTarget__c,
            assignedTarget.Contact__c,
            assignedTarget.StartDate__c
        );
    }

    /**
     * Restart the batch job for the next object
     */
    private void restartBatch() {

        PerformanceIndicatorsCalculatorBatch_V2 performanceIndicatorsCalculatorBatch =
            new PerformanceIndicatorsCalculatorBatch_V2(
                this.objectApiNames, this.indexForApiNames, this.dateModifier
            );
        Database.executeBatch(performanceIndicatorsCalculatorBatch);
    }

    /**
     * Class to store the information needed for a given SObject Category
     */
    @TestVisible
    private class PerformanceIndicatorCategory {

        @TestVisible private String objectApiName;
        @TestVisible private Map<Id, PerformanceTarget__c> performanceTargets;
        @TestVisible private Map<Id, List<SObjectFilterCondition__c>> numeratorFilters;
        @TestVisible private Map<Id, List<SObjectFilterCondition__c>> denumeratorFilters;
        @TestVisible private Set<String> fieldApiNames;
        @TestVisible private Set<String> pathsToContact;
        @TestVisible private List<PerformanceTarget__c> performanceTargetsToClose;

        /**
         * Constructor for the class
         *
         * @param objectApiName - The API name of the object that this Category is for
         */
        public PerformanceIndicatorCategory(String objectApiName) {
            this.objectApiName = objectApiName;
            this.performanceTargets = new Map<Id, PerformanceTarget__c>();
            this.numeratorFilters = new Map<Id, List<SObjectFilterCondition__c>>();
            this.denumeratorFilters = new Map<Id, List<SObjectFilterCondition__c>>();
            this.fieldApiNames = new Set<String>();
            this.pathsToContact = new Set<String>();
            this.performanceTargetsToClose = new List<PerformanceTarget__c>();
            this.getPerformanceTargetsForObject();
        }

        /**
         * Get all the PerformanceTarget.Id
         *
         * @return - A set containing the ids
         */
        public Set<Id> getPerformanceTargetIds() {
            return this.performanceTargets.keySet();
        }

        /**
         * Getter for the PerformanceTargets
         *
         * @return - Set of PerformanceTarget__c for this category
         */
        public List<PerformanceTarget__c> getPerformanceTargets() {
            return this.performanceTargets.values();
        }

        /**
         * Get all PerformanceTargets for this object type
         */
        private void getPerformanceTargetsForObject() {

            for (
                    PerformanceTarget__c performanceTarget :
                        new PerformanceTargetSelector().getAllWithSObjectFilterCondition(
                            this.objectApiName,
                            PerformanceTargetDO.TYPE_INDICATOR,
                            PerformanceTargetDO.STATUS_ACTIVE
                        )
            ) {
                if (
                        PerformanceTargetDO.operationRequireTrackedField(performanceTarget) &&
                        !addFieldApiName(
                            performanceTarget,
                            performanceTarget.TrackedFieldApiName__c
                        )
                ) {
                    continue;
                }
                if (
                        !addTrackedSObjectContactLookupField(
                            performanceTarget,
                            performanceTarget.TrackedSObjectContactLookupFieldName__c
                        )
                ) {
                    continue;
                }
                this.performanceTargets.put(performanceTarget.Id, performanceTarget);
                for (
                        SObjectFilterCondition__c filterCondtion :
                        performanceTarget.SObject_Filter_Conditions__r
                ) {
                    if (!addFieldApiName(performanceTarget, filterCondtion.FieldAPIName__c)) {
                        continue;
                    }
                    this.addNumeratorSObjectFilterCondition(filterCondtion, performanceTarget.Id);
                }
            }
        }

        /**
         * Add the field API name. Will check that the field exists
         *
         * @return - Boolean indicating if the field api name still exists
         */
        private Boolean addFieldApiName(
                PerformanceTarget__c performanceTarget,
                String fieldApiName
        ) {

            Boolean success = DescribeHandler.fieldExists(
                this.objectApiName,
                fieldApiName
            );
            if (success) {
                this.fieldApiNames.add(fieldApiName);
            } else {
                this.indicatePerformanceTargetToClose(performanceTarget);
            }
            return success;
        }

        /**
         * Add the tracked sobject - contact lookup path.
         * If path invalid will close the target
         */
        private Boolean addTrackedSObjectContactLookupField(
                PerformanceTarget__c performanceTarget,
                String trackedSObjectContactLookupField
        ) {

            Boolean success = DescribeHandler.validatePath(
                this.objectApiName,
                trackedSObjectContactLookupField
            );
            if (success) {
                this.pathsToContact.add(performanceTarget.TrackedSObjectContactLookupFieldName__c);
            } else {
                this.indicatePerformanceTargetToClose(performanceTarget);
            }
            return success;
        }

        /**
         * Indicate that a performance target needs to be closed at the end of the batch
         */
        public void indicatePerformanceTargetToClose(
                PerformanceTarget__c performanceTargetToClose
        ) {
            this.performanceTargets.remove(performanceTargetToClose.Id);
            this.performanceTargetsToClose.add(performanceTargetToClose);
        }

        /**
        * CLose all Performance Targets that have failed during the batch
        */
        public void closePerformanceTarget() {
            GenericObjectCreator performanceTargetCreator =
                new GenericObjectCreator(PerformanceTarget__c.getSObjectType());
            performanceTargetCreator.checkObjectAccessible();
            PerformanceTargetDO.setTargetsToAutomaticallyClosed(this.performanceTargetsToClose);
            performanceTargetCreator.checkObjectUpdateable();
            update this.performanceTargetsToClose;
        }

        /**
         * Get the objectApiName
         *
         * @return - String for the objectApiName
         */
        public String getObjectApiName() {
            return this.objectApiName;
        }

        /**
         * Get the field names that have been added to the object
         *
         * @return - The set of field names
         */
        public Set<String> getFieldNames() {
            return this.fieldApiNames;
        }

        /**
         * Get the fields that are needed in the SELECT clause
         *
         * @return - A set that includes both the fieldApiNames and the paths to contact
         */
        @TestVisible
        private Set<String> getSelectClauseFields() {
            Set<String> allFields = this.fieldApiNames;
            allFields.addAll(this.pathsToContact);
            allFields.addAll(new List<String>{'LastModifiedDate', 'CreatedDate'});
            allFields.remove(null);
            return allFields;
        }

        /**
         * Get the select clause as a joined string
         *
         * @return - A comma seperated string of all the fields needed in the select clause for
         *             the query to get the data for this object
         */
        public String getSelectClauseString() {

            List<String> allFieldsList = new List<String>();
            allFieldsList.addAll(this.getSelectClauseFields());
            return String.join(allFieldsList, ',');
        }

        /**
         * Add a filter condition to the object
         *
         * @param filter              - The SObjectFilterCondition__c being added
         * @param performanceTargetId - The Id of the target the filter is for
         */
        private void addNumeratorSObjectFilterCondition(
                SObjectFilterCondition__c filter,
                Id performanceTargetId
        ) {
            if (!this.numeratorFilters.containsKey(performanceTargetId)) {
                this.numeratorFilters.put(
                    performanceTargetId,
                    new List<SObjectFilterCondition__c>()
                );
            }
            this.numeratorFilters.get(performanceTargetId).add(filter);
            SObjectFilterConditionDO.addSelectQueryString(filter, this.objectApiName);
        }

        /**
         * Get the numerator filters for a given PerformanceTarget
         *
         * @param performanceTargetId - The PerformanceTarget__c.Id
         *
         * @return - A list of SObjectFilterConditions
         */
        public List<SObjectFilterCondition__c> getNumeratorFiltersForPerformanceTarget(
                Id performanceTargetId
        ) {
            List<SObjectFilterCondition__c> filters =
                this.numeratorFilters.get(performanceTargetId);
            if (filters == null) {
                filters = new List<SObjectFilterCondition__c>();
            }
            return filters;
        }
    }
}